
import com.fasterxml.jackson.databind.ObjectMapper;
import io.javalin.http.Context;
import io.javalin.validation.BodyValidator;
import mtogo.customer.DTO.OrderDetailsDTO;
import mtogo.customer.DTO.OrderLineDTO;
import mtogo.customer.DTO.menuItemDTO;
import mtogo.customer.controller.OrderController;
import mtogo.customer.exceptions.APIException;
import mtogo.customer.messaging.Producer;
import mtogo.customer.service.MenuService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class OrderControllerTest {

    @Mock
    Context ctx;

    @Mock
    BodyValidator<OrderDetailsDTO> bodyValidator;

    private OrderDetailsDTO buildValidOrder() {
        // orderId is generated by the controller, so we can leave it null in the body
        List<OrderLineDTO> lines = List.of(
                new OrderLineDTO(
                        10,
                        null,
                        2,
                        500.0f,
                        2
                )
        );

        return new OrderDetailsDTO(
                123,
                OrderDetailsDTO.orderStatus.created,
                lines,
                OrderDetailsDTO.PaymentMethod.PAYPAL
        );
    }

    @Test
    void createOrder_validOrder() throws Exception {
        OrderDetailsDTO dto = buildValidOrder();
        ObjectMapper mapper = new ObjectMapper();

        when(ctx.bodyValidator(OrderDetailsDTO.class)).thenReturn(bodyValidator);
        when(bodyValidator.check(any(), anyString())).thenReturn(bodyValidator);
        when(bodyValidator.get()).thenReturn(dto);

        when(ctx.status(anyInt())).thenReturn(ctx);
        when(ctx.json(any())).thenReturn(ctx);

        try (MockedStatic<Producer> producerMock = mockStatic(Producer.class)) {
            OrderController controller = OrderController.getInstance();

            controller.createOrder(ctx);

            String expectedPayload = mapper.writeValueAsString(dto);

            producerMock.verify(() ->
                    Producer.publishMessage("customer:order_creation", expectedPayload)
            );

            verify(ctx).status(201);
            verify(ctx).json(dto);
        }
    }


    @Test
    void createOrder_fail() throws Exception {
        OrderController controller = OrderController.getInstance();
        OrderDetailsDTO orderDetailsDTO = buildValidOrder();
        when(ctx.status(anyInt())).thenReturn(ctx);


        when(ctx.bodyValidator(OrderDetailsDTO.class)).thenReturn(bodyValidator);
        when(bodyValidator.check(any(), anyString())).thenReturn(bodyValidator);
        when(bodyValidator.get()).thenReturn(orderDetailsDTO);

        try (MockedStatic<Producer> producerMock = mockStatic(Producer.class)) {
            // Simulate RabbitMQ failure
            producerMock.when(() ->
                    Producer.publishMessage(anyString(), anyString())
            ).thenThrow(new APIException(500, "RabbitMQ failure"));

            controller.createOrder(ctx);

            verify(ctx).status(500);
            verify(ctx).result("Failed to publish order creation message");
        }
    }

    @Test
    void validateOrderDTO() {
        OrderController controller = OrderController.getInstance();
        OrderDetailsDTO expected = buildValidOrder();

        when(ctx.bodyValidator(OrderDetailsDTO.class)).thenReturn(bodyValidator);
        when(bodyValidator.check(any(), anyString())).thenReturn(bodyValidator);
        when(bodyValidator.get()).thenReturn(expected);

        OrderDetailsDTO actual = controller.validateOrderDTO(ctx);

        assertNotNull(actual);
        assertEquals(expected.getOrderId(), actual.getOrderId());
    }

    @Test
    void getItemsBySupplierId_returns200AndItems() throws Exception {

        OrderController controller = OrderController.getInstance();

        when(ctx.pathParam("supplierId")).thenReturn("1");

        when(ctx.status(anyInt())).thenReturn(ctx);
        when(ctx.json(any())).thenReturn(ctx);

        // Fake menu items returned from MenuService
        List<menuItemDTO> fakeItems = List.of(
                new menuItemDTO(1, "Pizza", 85.0, 1, true),
                new menuItemDTO(2, "Burger", 60.0, 1, true)
        );

        try (MockedStatic<MenuService> menuServiceStatic = Mockito.mockStatic(MenuService.class)) {
            MenuService menuServiceMock = mock(MenuService.class);

            // When MenuService.getInstance() is called, return our mock
            menuServiceStatic.when(MenuService::getInstance).thenReturn(menuServiceMock);

            // When requestMenuBlocking(1) is called, return fakeItems
            when(menuServiceMock.requestMenuBlocking(1)).thenReturn(fakeItems);

            controller.getItemsBySupplierId(ctx);

            verify(menuServiceMock).requestMenuBlocking(1);
            verify(ctx).status(200);
            verify(ctx).json(fakeItems);
            verify(ctx, never()).result(anyString());
        }
    }

}
